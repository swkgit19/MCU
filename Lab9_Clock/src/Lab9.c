/*
===============================================================================
 Name        : Lab9.c
 Author      : $(author)
 Version     :
 Copyright   : $(copyright)
 Description : main definition
===============================================================================
*/

#ifdef __USE_CMSIS
#include "LPC17xx.h"
#endif

#include <stdio.h>

//Section 1.5
/*

#define CLOCK_SETUP		1
#define SCS_Val			0x00000020
#define CLKSRCSEL_Val	0x00000001
#define PLL0_SETUP		1
#define PLL0CFG_Val		0x00050063
#define PLL1_SETUP		1
#define PLL1CFG_Val		0x00000023
#define CCLKCFG_Val		0x00000003
#define USBCLKCFG_Val	0x00000000
#define PCLKSEL0_Val	0x00000000
#define PCLKSEL1_Val	0x00000000
#define PCONP_Val		0x042887DE
#define CLKOUTCFG_Val	0x00000000

void SystemInit (void)
{
if(CLOCK_SETUP)
	LPC_SC->SCS = SCS_Val;
	if(SCS_Val & (1 << 5))
	{
		while((LPC_SC->SCS & (1 << 6)) == 0);
	}

	LPC_SC->CCLKCFG = CCLKCFG_Val;

	LPC_SC->PCLKSEL0 = PCLKSEL0_Val;
	LPC_SC->PCLKSEL1 = PCLKSEL1_Val;

	LPC_SC->CLKSRCSEL = CLKSRCSEL_Val;

if(PLL0_SETUP)
	LPC_SC->PLL0CFG = PLL0CFG_Val;
}
*/

//Section 2
/*
int main(void)
{
	//configure P1.27 to 0 - CLKOUT
	LPC_PINCON->PINSEL3 |= (1<<22);
	LPC_PINCON->PINSEL3 &= (~(1<<23));
	//Enable CLKOUT and Select CPU Clock as CLKOUT source
	LPC_SC->CLKOUTCFG = 0x100;
	while(1)
	return 0;
}
*/

//Section 2.4
//System Tick Timer Sample Program
/*
int i;

void SysTick_Init(void)
{
	//Set value for SysTick Reload Value Register
	SysTick->LOAD = 999999;
	//Enable SysTick Counter, SysTick Interrupt & Select CPU Clock
	//source.
	SysTick->CTRL = (1 << 0) | (1 << 1) | (1 << 2);
}

void SysTick_Handler(void)
{
	printf("SysTick is counting %d\n", i++);	//Respond will appear on Console.
}

int main(void)
{
	SysTick_Init();
	while(1);

	return 0;
}
*/

//Section 3.2
//Real Time Clock Sample Program
/*
void RTC_Power_Init(void)
{
	//Turn on Power for RTC Interface
	LPC_SC->PCONP |= (1<<9);
}

void RTC_Init(void)
{
	//Initialize CCR Register
	LPC_RTC->CCR = 0;
	//Enable Clock
	LPC_RTC->CCR |= (1<<0);
	//Reset Internal Oscillator Divider
	LPC_RTC->CCR |= (1<<1); 		//Latching Purpose
	LPC_RTC->CCR |= (~(1<<1));		//Latching Purpose
	//Set Interrupt to occur every second.
	LPC_RTC->CIIR |= (1<<0);
	//Reset Interrupt
	LPC_RTC->ILR = (3<<0);
}

void RTC_IRQHandler(void)
{
	//Check if Interrupt is generated by Counter Increment
	LPC_RTC->ILR = (1<<0);
	{
		//Clear Interrupt
		LPC_RTC->ILR = (1<<0);
		printf("Date(%d:%d:%d)/Time(%d:%d:%d)\n",					//No output on Console, b'cos is Realtime clock
				LPC_RTC->YEAR, LPC_RTC->MONTH, LPC_RTC->DOM,
				LPC_RTC->HOUR, LPC_RTC->MIN, LPC_RTC->SEC);
	}
}

int main(void)
{
	RTC_Power_Init();
	RTC_Init();
	LPC_RTC->YEAR = 2013;
	LPC_RTC->MONTH = 11;
	LPC_RTC->DOM = 12;
	LPC_RTC->HOUR = 8;
	LPC_RTC->MIN = 18;
	LPC_RTC->SEC = 28;

	//Enable Interrupt
	NVIC_EnableIRQ(RTC_IRQn);
	while(1);
	return 0;
}
*/

//Section 4.2
//Part 1 & 2
/*
void WDT_Init(void)
{
	//Set IRC oscillator as the Watchdog clock source
	LPC_WDT->WDCLKSEL &= (~(3<<0));
	//Set Watchdog timeout interval to 5000000
	LPC_WDT->WDTC = 5000000;
	//Configure Watchdog to reset
	LPC_WDT->WDMOD |= (1<<1);
	//Enable Watchdog.
	LPC_WDT->WDMOD |= (1<<0);
}

void WDT_Feed(void)
{
	//Reload Watchdog counter value
	LPC_WDT->WDFEED = 0xAA;
	LPC_WDT->WDFEED = 0x55;
}

int main(void)
{
	print("Watchdog Test\n");
	WDT_Init();
	WDT_Feed();
	while(1)
	{
		//Check if watchdog timer value is equal to 0.
		if(LPC_WDT->WDTV == 0)
		{
			printf("Watchdog Timeout and Reset\n");
		}
		else
		{
			//Printing Watchdog timer current value
			printf("Watchdog Counting %d\n", LPC_WDT->WDTV);

			//Part 3
			WDT_Feed();
		}
	}
	return 0;
}
*/

